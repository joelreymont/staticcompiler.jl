#!/usr/bin/env julia

"""
Code Quality Analysis Tool for StaticCompiler.jl

Analyzes Julia code before compilation to identify potential issues
and optimization opportunities.

Usage:
    analyze-code <source.jl> <function_name> [types...]
    analyze-code --help

Examples:
    analyze-code hello.jl main
    analyze-code mylib.jl compute Int,Float64
"""

using StaticCompiler
using ArgParse

function parse_commandline()
    s = ArgParseSettings(
        prog = "analyze-code",
        description = "Analyze Julia code quality before compilation"
    )

    @add_arg_table! s begin
        "source"
            help = "Julia source file"
            required = true

        "function"
            help = "Function name to analyze"
            required = true

        "types"
            help = "Comma-separated argument types (optional)"
            required = false
            default = ""

        "--min-score"
            help = "Minimum acceptable score (0-100)"
            arg_type = Int
            default = 80

        "--export"
            help = "Export analysis to JSON file"
            arg_type = String
            default = nothing

        "--verbose", "-v"
            help = "Show detailed analysis"
            action = :store_true
    end

    return parse_args(s)
end

function parse_types(type_str::String)
    if isempty(type_str)
        return ()
    end

    parts = split(type_str, ',')
    types = []

    for part in parts
        part = strip(part)
        jl_type = if part == "Int"
            Int
        elseif part == "Int64"
            Int64
        elseif part == "Int32"
            Int32
        elseif part == "Float64"
            Float64
        elseif part == "Float32"
            Float32
        elseif startswith(part, "Ptr{")
            inner = part[5:end-1]
            if inner == "UInt8"
                Ptr{UInt8}
            elseif inner == "Float64"
                Ptr{Float64}
            else
                error("Unknown pointer type: $part")
            end
        else
            error("Unknown type: $part")
        end
        push!(types, jl_type)
    end

    return Tuple(types)
end

function main()
    args = parse_commandline()

    source_file = args["source"]
    func_name = args["function"]

    # Load source file
    if !isfile(source_file)
        println("Error: Source file not found: $source_file")
        exit(1)
    end

    include(source_file)

    # Get function
    func_symbol = Symbol(func_name)
    if !isdefined(Main, func_symbol)
        println("Error: Function '$func_name' not found in $source_file")
        exit(1)
    end

    func = getfield(Main, func_symbol)

    # Parse types
    types = try
        parse_types(args["types"])
    catch e
        println("Error parsing types: $e")
        exit(1)
    end

    println("=" ^ 70)
    println("Code Quality Analysis")
    println("=" ^ 70)
    println()
    println("Function: $func_name")
    println("Types: $types")
    println()

    try
        # Run analysis using quick_check
        report = quick_check(func, types)

        # Display results
        println("Analysis Results:")
        println("-" ^ 70)
        println()

        println("Overall Score: $(report.score)/100")
        status_icon = report.ready_for_compilation ? "✅" : "❌"
        println("Status: $status_icon $(report.score >= args["min-score"] ? "PASS" : "FAIL")")
        println()

        if !isempty(report.issues)
            println("Issues Found:")
            for (i, issue) in enumerate(report.issues)
                println("  $i. $issue")
            end
            println()
        else
            println("✅ No issues found!")
            println()
        end

        if args["verbose"]
            println("Detailed Analysis:")
            println("-" ^ 70)
            println()

            println("Escape Analysis:")
            println("  Heap allocations: $(length(report.escape_analysis.allocations))")
            if !isempty(report.escape_analysis.allocations)
                for alloc in report.escape_analysis.allocations
                    println("    • Line $(alloc.line): $(alloc.description)")
                end
            end
            println()

            println("Monomorphization:")
            println("  Has abstract types: $(report.monomorphization_analysis.has_abstract_types ? "❌" : "✅")")
            if report.monomorphization_analysis.has_abstract_types
                for (idx, at) in enumerate(report.monomorphization_analysis.abstract_types)
                    println("    • $idx. $at")
                end
            end
            println()

            println("Devirtualization:")
            println("  Dynamic dispatch sites: $(report.devirtualization_analysis.total_dynamic_calls)")
            if report.devirtualization_analysis.total_dynamic_calls > 0
                for call in report.devirtualization_analysis.dynamic_calls
                    println("    • Line $(call.line): $(call.function_name)")
                end
            end
            println()

            println("Lifetime Analysis:")
            println("  Potential memory leaks: $(report.lifetime_analysis.potential_leaks)")
            println()
        end

        # Export if requested
        if !isnothing(args["export"])
            # Export as JSON
            using JSON
            open(args["export"], "w") do io
                JSON.print(io, Dict(
                    "function_name" => string(report.function_name),
                    "score" => report.score,
                    "ready_for_compilation" => report.ready_for_compilation,
                    "issues" => report.issues,
                    "analyses" => Dict(
                        "monomorphization" => Dict(
                            "has_abstract_types" => report.monomorphization_analysis.has_abstract_types,
                            "abstract_types" => string.(report.monomorphization_analysis.abstract_types)
                        ),
                        "escape" => Dict(
                            "num_allocations" => length(report.escape_analysis.allocations)
                        ),
                        "devirtualization" => Dict(
                            "dynamic_calls" => report.devirtualization_analysis.total_dynamic_calls
                        ),
                        "lifetime" => Dict(
                            "potential_leaks" => report.lifetime_analysis.potential_leaks
                        )
                    )
                ), 2)
            end
            println("Analysis exported to: $(args["export"])")
            println()
        end

        # Summary
        println("=" ^ 70)
        if report.score >= args["min-score"]
            println("✅ Code quality acceptable for compilation")
        else
            println("❌ Code quality below threshold ($(args["min-score"]))")
            println("   Consider addressing the issues above before compilation")
        end
        println("=" ^ 70)

        # Exit with appropriate code
        exit(report.score >= args["min-score"] ? 0 : 1)

    catch e
        println("Error during analysis:")
        println(e)
        if args["verbose"]
            println()
            showerror(stdout, e, catch_backtrace())
        end
        exit(1)
    end
end

if abspath(PROGRAM_FILE) == @__FILE__
    main()
end
